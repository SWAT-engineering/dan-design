@encoding{LitteEndian}
syntax FAT16Format(syntax nestedFilesParser) =
    Reserved resv
    FAT(resv.boot.block_2_0) [resv.boot.block_2_0.fatCount] fatArea
    RootDirectory(nestedFilesParser, resv.boot.block_2_0, &fatArea, &root) [resv.boot.block_2_0.maxRootDirectoryEntryCount] root
    ;

syntax Reserved =
    BootSector boot
    // maybe we need a short alias for this ?
    u8[boot.biosBlock.block_2_0.bytesPerLogicalSector * (boot.biosBlock.block_2_0.reservedSectorCount - 1)] restData
    ;

syntax BootSector =
    u24 jumpInstruction
    u8[8] oemName
    BiosParameterBlock biosBlock
    u8[0x1fd - &bootCode] bootCode // a self offset link
    u8 physicalDriveNumber
    u16 bootSectorSignature == 0xaa55
    ;

syntax FAT[BPB20 bootSector] = u8[bootSector.logicalSectorsPerFat * bootSector.bytesPerLogicalSector] table; // might need to skip

// alternatives have to be named, so they can be indexed from the context by their name
// we might have to think of a way to reference any of them.
syntax RootDirectory(syntax nestedFilesParser, BootSector bpe, offset firstFat, offset firstRoot )
    = empty: EmptyEntry
    | longfile: VFATLongFileName
    | dir: DirectoryEntry(nestedFilesParser, bpe, firstFat, firstRoot)
    ;

// 0x20 zero's
syntax EmptyEntry = u8[0x20] empty == 0x0;

syntax DirectoryEntry((syntax nestedFilesParser, BootSector bpe, offset firstFat, offset firstRoot) = 
    u8[8] shortFileName
    u8[3] extension
    u8 attributes
    u8[2] _ // ignored fields
    u16[6] _ // ignored fields
    u16 nextCluster
    u32 fileSize
    Data(nextCluser, bpe.clusterSize, bpe.block_2_0.maxRootDirectoryEntryCount, firstRoot) firstData
    Pointer(nextCluser, bpe.clusterSize, bpe.block_2_0..maxRootDirectoryEntryCount, firstFat, firstRoot)* nextData

    virtual u32 clusterCount {
        slackSize = bpe.clusterSize - (fileSize % bpe.clusterSize );
        return (slackSize + fileSize) / bpe.clusterSize;
    }

    // need to think about this syntax around nested parsing, and the cat & ranges syntax
    parse(nestedFilesParser, cat(d.data, nextData[0:clusterCount]))   fileEntry

}

// start at an offset from the start of the file
// not sure about this, seems a bit un scope sensitive.
syntax Data(u16 nextCluster, u32 clusterSize, u16 maxRootEntries, offset firstRoot)
    = @(firstRoot + (0x20 * maxRootEntries) + ((nextCluster - 2) * clusterSize)) 
        u8[clusterSize] data;

syntax Pointer(u16 nextCluster, u32 clusterSize, u16 maxRootEntries, offset firstFat, offset firstRoot) = 
    @(firstFat + (nextCluster * 2)) u16 nextCluster == 0xFFF8
    Data(nextCluster, clusterSize, maxRootEntries, firstRoot) moreData // points to new nextCluster field
    ;

syntax VFATLongFileName =
    u8 sequenceNumber
    u8[10] nameCharacters
    u8 attributes == 0x0F
    u8 type == 0x0
    u8 checksum
    u8[12] nameCharacters2
    u16 nextCluster == 0x0
    u8[4] nameCharacters3
    ;



syntax BPB20 =
    u16 bytesPerLogicalSector
    u8 logicalSectorsPerCluster
    u16 reservedSectorCount
    u8 fatCount
    u16 maxRootDirectoryEntryCount
    ...
    u16 logicalSectorsPerFat
    ;

syntax EBPB =
    ...;

syntax BPB331 =
    ...;

syntax BiosParameterBlock =
    BPB20 block_2_0
    BPB331 block_3_31
    EBPB extendeBlock

    virtual u32 clusterSize = block_2_0.bytesPerLogicalSector * block_2_0.logicalSectorsPerCluster;
    ;

